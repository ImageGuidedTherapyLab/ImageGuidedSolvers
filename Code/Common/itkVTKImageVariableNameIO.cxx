/*=========================================================================

  Program:   Insight Segmentation & Registration Toolkit
  Module:    $RCSfile: itkVTKImageIO.cxx,v $
  Language:  C++
  Date:      $Date: 2009-04-05 10:56:48 $
  Version:   $Revision: 1.48 $

  Copyright (c) Insight Software Consortium. All rights reserved.
  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

  Portions of this code are covered under the VTK copyright.
  See VTKCopyright.txt or http://www.kitware.com/VTKCopyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#include "itkVTKImageVariableNameIO.h"
#include "itkByteSwapper.h"

#include <itksys/ios/sstream>

#include <stdio.h>
#include <string.h>

namespace itk
{

// this class is a minor hack of itkVTKImageIO
VTKImageVariableNameIO::VTKImageVariableNameIO():Superclass()
{
}

VTKImageVariableNameIO::~VTKImageVariableNameIO()
{
}

void VTKImageVariableNameIO::Write(const void* buffer)
{
  std::ofstream file;
  if ( ! this->OpenVTKFileForWriting(file,m_FileName.c_str()) )
    {
    return;
    }

  // Check the image region for proper dimensions, etc.
  unsigned int numDims = this->GetNumberOfDimensions();
  if ( numDims < 2 || numDims > 3 )
    {
    itkExceptionMacro(<<"VTK Writer can only write 2 or 3-dimensional images");
    return;
    }
  ImageIORegion ioRegion = this->GetIORegion();

  // Write the VTK header information
  file << "# vtk DataFile Version 3.0\n"; 
  file << "VTK File Generated by Insight Segmentation and Registration Toolkit (ITK)\n";
  
  if ( this->GetFileType() == ASCII ) 
    {
    file << "ASCII\n"; 
    }
  else 
    {
    file << "BINARY\n"; 
    }

  // Save original formatting flags
  const itksys_ios::ios::fmtflags originalFlags     = file.flags();
#if (defined(__GNUC__) && (__GNUC__ <=2))
  const itksys_ios::ios::streamsize    originalPrecision = file.precision();
#else
  const itksys_ios::streamsize    originalPrecision = file.precision();
#endif

  file.setf( itksys_ios::ios::scientific, 
             itksys_ios::ios::floatfield );
  
  file.precision(16);

  // Write characteristics of the data
  file << "DATASET STRUCTURED_POINTS\n";
  if ( numDims == 2 )
    {
    file << "DIMENSIONS " << this->GetDimensions(0) << " "
         << this->GetDimensions(1) << " 1\n";
    file << "SPACING " << m_Spacing[0] << " " << m_Spacing[1] << " 1.0\n";
    file << "ORIGIN " << m_Origin[0] << " " << m_Origin[1] << " 0.0\n";
    }
  else //numDims == 3
    {
    file << "DIMENSIONS " << this->GetDimensions(0) << " "
         << this->GetDimensions(1) << " " << this->GetDimensions(2) << "\n";
    file << "SPACING " << m_Spacing[0] << " " 
         << m_Spacing[1] << " " << m_Spacing[2] << "\n";
    file << "ORIGIN " << m_Origin[0] << " "
         << m_Origin[1] << " " << m_Origin[2] << "\n";
    }

  // Restore the original formatting flags
  file.flags( originalFlags );
  file.precision( originalPrecision );

  file << "POINT_DATA " << this->GetImageSizeInPixels() << "\n";

  // Prefer the VECTORS representation when possible:
  if( this->GetPixelType() == ImageIOBase::VECTOR && this->GetNumberOfComponents() == 3 )
    {
    file << "VECTORS " << m_VariableName  << " " 
      << this->GetComponentTypeAsString(m_ComponentType) << "\n";
    }
  else
    {
    // According to VTK documentation number of components should in range (1,4):
    file << "SCALARS " << m_VariableName  << " " 
      << this->GetComponentTypeAsString(m_ComponentType) << " "
      << this->GetNumberOfComponents() << "\n"
      << "LOOKUP_TABLE default\n";
    }

  // Write the actual pixel data
  if ( m_FileType == ASCII )
    {
    this->WriteBufferAsASCII(file, buffer, this->GetComponentType(),
                             this->GetImageSizeInComponents());
    }
  else //binary
    {
    int size = this->GetComponentSize();
    typedef ::size_t   BufferSizeType;
    const BufferSizeType numbytes = static_cast<BufferSizeType>( this->GetImageSizeInBytes() );
    char * tempmemory=new char[numbytes];
    memcpy(tempmemory,buffer,numbytes);
    switch( size )
      {
      case 2:
        {
        ByteSwapper<short>::SwapRangeFromSystemToBigEndian(reinterpret_cast<short *>(tempmemory), static_cast<BufferSizeType>(this->GetImageSizeInComponents()) );
        }
        break;
      case 4:
        {
        ByteSwapper<float>::SwapRangeFromSystemToBigEndian(reinterpret_cast<float *>(tempmemory), static_cast<BufferSizeType>(this->GetImageSizeInComponents()) );
        }
        break;
      case 8:
        {
        ByteSwapper<double>::SwapRangeFromSystemToBigEndian(reinterpret_cast<double *>(tempmemory), static_cast<BufferSizeType>(this->GetImageSizeInComponents()) );
        }
        break;
      }
            file.write(static_cast<const char*>(tempmemory), static_cast<std::streamsize>(this->GetImageSizeInBytes()));
    delete [] tempmemory;
    }
}

void VTKImageVariableNameIO::PrintSelf(std::ostream& os, Indent indent) const
{
  Superclass::PrintSelf(os, indent);
  std::cout << m_VariableName << std::endl;
}

} // end namespace itk
